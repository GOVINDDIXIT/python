import time
import concurrent.futures

start = time.perf_counter()


def foo(sleep_time):
	print(f'Sleeping for {sleep_time} second...')
	time.sleep(sleep_time)
	return 'Done Sleeping...'


with concurrent.futures.ProcessPoolExecutor() as executor:
    results = []
    for i in range(10):
        results.append(executor.submit(foo, 1))

    for f in concurrent.futures.as_completed(results):
        print(f.result())


finish = time.perf_counter()

print(f'Finished in {round(finish-start, 2)} second(s)')

# Output

# The time is increased because ProcessPoolExecutor has made decision on the basis of hardware to not to allot as many processes run parallely

# Sleeping for 1 second...
# Sleeping for 1 second...
# Sleeping for 1 second...
# Sleeping for 1 second...
# Sleeping for 1 second...
# Done Sleeping...
# Sleeping for 1 second...
# Sleeping for 1 second...
# Sleeping for 1 second...
# Done Sleeping...
# Done Sleeping...
# Done Sleeping...
# Sleeping for 1 second...
# Done Sleeping...
# Sleeping for 1 second...
# Done Sleeping...
# Done Sleeping...
# Done Sleeping...
# Done Sleeping...
# Done Sleeping...
# Finished in 3.39 second(s)
